"""Convert AWS Transcribe JSON format to Dictation Format"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_PyTranscribe.ipynb.

# %% auto 0
__all__ = ['DEFAULT_LANGUAGE_CODE', 'JsonToDictation', 'start_job', 'AWSTranscribe']

# %% ../nbs/01_PyTranscribe.ipynb 3
class JsonToDictation:
    "A class that will convert the AWS Transcribe to Dictation"

    def __init__(self,
                 speakers,
                 data # JSON data that has been generated by AWS Transcribe
                ):
        self.transcribe_data = data
        self.titles = []
        self.num_speakers = 0
        self.speakers = speakers
        self.speaker_map = []
        self.text = ''
        self.load()


    def load(self):
        self.titles = self.transcribe_data["results"]["transcripts"]
        self.num_speakers = self.transcribe_data["results"]["speaker_labels"]["speakers"] 
        speaker_set = set(self.speakers)
        #self.num_speakers = len(speaker_set)
        self.getSpeakerMap()
        
    def getSpeakerMap(self):
        for segment in self.transcribe_data["results"]["speaker_labels"]["segments"]:
            speaker = segment["speaker_label"]            
            self.speaker_map.append(speaker)
        return (self.speaker_map)

    def applyFormattingRules(self, word: str) -> str:
        # translate some spellings into standarized format
        if word.upper() == "OK":
            return "Okay "
        if word == "Cuz":
            return "Because "
        if word == "cuz":
            return "because "
            
        # remove um and ah from text output
        if word.upper() == "UM":
            return ""
        if word.upper() == "AH":
            return ""

        # none of the above, then return word with a space after
        return f"{word} "       
        
    def convert(self):
        str = ''
        current_speaker = ''
        for item in self.transcribe_data["results"]["items"]:
            alternatives = item["alternatives"]
            speaker_label = item["speaker_label"]
            speaker_index = self.speaker_map.index(speaker_label)
            speaker = self.speakers[speaker_index]
            word = alternatives[0]["content"]
            type = item["type"]

            if current_speaker != speaker:
                if current_speaker != '':
                    str += "\n"
                    
                current_speaker = speaker                
                str += f"{speaker}:\t"

            if type == "punctuation":
                str = str[:-1]

            str += self.applyFormattingRules(word)
            
        self.text = str        
        return (str)        
            
    def summary(self):
        print(f"{self.num_speakers=}")
        print(f"{self.speakers=}")
        print(f"{self.speaker_map=}")
        print(f"{speakers=}")


# %% ../nbs/01_PyTranscribe.ipynb 7
DEFAULT_LANGUAGE_CODE="en-US"


def start_job(
    job_name,
    media_uri,
    media_format,
    language_code,
    transcribe_client,
    vocabulary_name=None,
):
    """
    Starts a transcription job. This function returns as soon as the job is started.
    To get the current status of the job, call get_transcription_job. The job is
    successfully completed when the job status is 'COMPLETED'.

    :param job_name: The name of the transcription job. This must be unique for
                     your AWS account.
    :param media_uri: The URI where the audio file is stored. This is typically
                      in an Amazon S3 bucket.
    :param media_format: The format of the audio file. For example, mp3 or wav.
    :param language_code: The language code of the audio file.
                          For example, en-US or ja-JP
    :param transcribe_client: The Boto3 Transcribe client.
    :param vocabulary_name: The name of a custom vocabulary to use when transcribing
                            the audio file.
    :return: Data about the job.
    """
    try:
        job_args = {
            "TranscriptionJobName": job_name,
            "Media": {"MediaFileUri": media_uri},
            "MediaFormat": media_format,
            "LanguageCode": language_code,
        }
        if vocabulary_name is not None:
            job_args["Settings"] = {"VocabularyName": vocabulary_name}
        response = transcribe_client.start_transcription_job(**job_args)
        job = response["TranscriptionJob"]
        logger.info("Started transcription job %s.", job_name)
    except ClientError:
        logger.exception("Couldn't start transcription job %s.", job_name)
        raise
    else:
        return job        
        pass

class AWSTranscribe:
    "A class that will upload audio files to s3 and then execute transcription jobs for them using AWSTranscribe"

    def __init__(self, input_bucket, output_bucket):
        self.s3_client = boto3.client('s3')
        self.transcribe_client = boto3.client('transcribe')
        self.input_bucket = input_bucket
        self.output_bucket = output_bucket

    def printInputBucketContents(self):
        return self.printBucketContents(self.input_bucket)

    def printOutputBucketContents(self):
        return self.printBucketContents(self.output_bucket)
    
        
    def printBucketContents(self, bucket):
        response = self.s3_client.list_objects_v2(Bucket=bucket)
        for content in response['Contents']:
            obj_dict = self.s3_client.get_object(Bucket=bucket, Key=content['Key'])
            print(content['Key'], obj_dict['LastModified'])

    def uploadFile(self, file_name):
        object_name = os.path.basename(file_name)
        try:
            response = self.s3_client.upload_file(file_name, self.input_bucket, object_name)
        except ClientError as e:
            print(error(e))
            logging.exception("Cannot upload file to s3: "+e)
            raise
        return response

    def getFileType(self, file_name):
        kind = filetype.guess(file_name)
        if kind is None:
            print('Cannot guess file type!')
            logger.exception("Cannot guess file type!")
            raise

        #print('File extension: %s' % kind.extension)
        #print('File MIME type: %s' % kind.mime)        
        return kind.extension

    def createTranscriptionJob(self, file_name):
        media_format = self.getFileType(file_name)

        # upload file to s3 (inputbucket)
        # wait for upload to be done
        # construct media_url
        # construct job_name
        # create transcription job
    
        # job = start_job(job_name, media_uri, media_format, language_code, self.transcribe_client):
        

    def getTranscriptionJob(self, job_name):
        response = self.transcribe_client.get_transcription_job(TranscriptionJobName=job_name)
        return response

    def isJobComplete(self, job_name) -> bool:        
        result = self.getTranscriptionJob(job_name)
        return str(result['TranscriptionJob']['TranscriptionJobStatus']) == 'COMPLETED'
